package syslimit

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	tmpl "tcsss/internal/config"
)

// LimitsConfApplier manages system-wide resource limits configuration.
// Writes configuration files that affect NEW sessions/processes.
type LimitsConfApplier struct {
	logger      *slog.Logger
	rlimits     map[string]string // rlimit values from templates
	templateDir string
}

// NewLimitsConfApplier creates a new instance.
func NewLimitsConfApplier(logger *slog.Logger, templateDir string) *LimitsConfApplier {
	return &LimitsConfApplier{
		logger:      logger,
		rlimits:     make(map[string]string),
		templateDir: templateDir,
	}
}

// fileConfig defines a configuration file to be written.
type fileConfig struct {
	path    string
	content string
	perm    os.FileMode
}

// parseRlimitsFromTemplate extracts rlimit.* entries from template content.
func (lca *LimitsConfApplier) parseRlimitsFromTemplate(content string) {
	for _, line := range strings.Split(content, "\n") {
		line = strings.TrimSpace(line)

		if !strings.HasPrefix(line, "rlimit.") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(strings.TrimPrefix(parts[0], "rlimit."))
		value := strings.TrimSpace(parts[1])
		lca.rlimits[key] = value
	}
}

// loadRlimitsFromTemplates loads and merges rlimit values from templates.
func (lca *LimitsConfApplier) loadRlimitsFromTemplates(templates tmpl.TemplateSet) {
	lca.parseRlimitsFromTemplate(templates.Common)
	lca.parseRlimitsFromTemplate(templates.Specific) // Overrides common
}

// generateLimitsConf generates /etc/security/limits.conf content.
// Only includes limits defined in templates.
// Excludes stack/core if set to unlimited to avoid conflicts with /etc/profile.
func (lca *LimitsConfApplier) generateLimitsConf() string {
	if len(lca.rlimits) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString("# Generated by tcsss - System resource limits\n")
	sb.WriteString("# Applied via PAM for new login sessions\n")
	sb.WriteString("# Note: stack/core unlimited values handled by /etc/profile\n\n")

	// Order matters for readability
	order := []string{"nofile", "nproc", "memlock", "stack", "core", "cpu", "as", "data", "fsize", "msgqueue", "sigpending", "locks"}

	for _, res := range order {
		value, ok := lca.rlimits[res]
		if !ok {
			continue
		}

		// Skip stack/core if unlimited - let /etc/profile handle it
		// This prevents "Operation not permitted" errors when /etc/profile
		// tries to set ulimit -s unlimited or ulimit -c unlimited
		if (res == "stack" || res == "core") && value == "unlimited" {
			lca.logger.Debug("skipping unlimited limit in PAM config",
				slog.String("resource", res),
				slog.String("reason", "handled by /etc/profile"))
			continue
		}

		sb.WriteString(fmt.Sprintf("*  soft  %-12s %s\n", res, value))
		sb.WriteString(fmt.Sprintf("*  hard  %-12s %s\n", res, value))
	}

	return sb.String()
}

// generateSystemdConf generates /etc/systemd/system.conf content.
// Only includes limits defined in templates.
func (lca *LimitsConfApplier) generateSystemdConf() string {
	if len(lca.rlimits) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString("# Generated by tcsss - systemd default resource limits\n")
	sb.WriteString("# Reload: systemctl daemon-reexec\n\n")
	sb.WriteString("[Manager]\n")

	// Map rlimit names to systemd configuration keys
	mapping := map[string]string{
		"nofile":  "DefaultLimitNOFILE",
		"nproc":   "DefaultLimitNPROC",
		"memlock": "DefaultLimitMEMLOCK",
		"stack":   "DefaultLimitSTACK",
		"core":    "DefaultLimitCORE",
		"cpu":     "DefaultLimitCPU",
		"as":      "DefaultLimitAS",
		"data":    "DefaultLimitDATA",
		"fsize":   "DefaultLimitFSIZE",
	}

	order := []string{"nofile", "nproc", "memlock", "stack", "core", "cpu", "as", "data", "fsize"}

	for _, key := range order {
		value, ok := lca.rlimits[key]
		if !ok {
			continue
		}

		// Stack: convert KB to bytes for systemd
		if key == "stack" && value != "unlimited" {
			if v, err := strconv.ParseUint(value, 10, 64); err == nil {
				value = fmt.Sprintf("%d", v*1024)
			}
		}

		// Systemd uses "infinity" instead of "unlimited"
		if value == "unlimited" {
			value = "infinity"
		}

		sb.WriteString(fmt.Sprintf("%s=%s\n", mapping[key], value))
	}

	return sb.String()
}

// Apply writes system-wide resource limit configuration files.
// Only writes limits that are explicitly defined in templates.
func (lca *LimitsConfApplier) Apply(ctx context.Context) error {
	// Detect memory tier and load templates
	templates, err := tmpl.DetectTemplateSet(lca.templateDir)
	if err != nil {
		lca.logger.Warn("memory detection failed, using default tier",
			slog.String("error", err.Error()))
	}

	// Load rlimits from templates
	lca.loadRlimitsFromTemplates(templates)

	if len(lca.rlimits) == 0 {
		lca.logger.Warn("no rlimits defined in templates")
		return nil
	}

	lca.logger.Info("applying limits configuration",
		slog.String("memory_tier", templates.MemoryConfig.MemoryLabel),
		slog.Int("limits", len(lca.rlimits)))

	// Generate configuration files (only non-empty ones)
	configs := []fileConfig{
		{
			path:    "/etc/security/limits.conf",
			content: lca.generateLimitsConf(),
			perm:    0644,
		},
		{
			path:    "/etc/systemd/system.conf",
			content: lca.generateSystemdConf(),
			perm:    0644,
		},
	}

	// Write files
	written := 0
	for _, cfg := range configs {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		if cfg.content == "" {
			continue
		}

		if err := os.MkdirAll(filepath.Dir(cfg.path), 0755); err != nil {
			lca.logger.Warn("mkdir failed",
				slog.String("dir", filepath.Dir(cfg.path)),
				slog.String("error", err.Error()))
			continue
		}

		if err := writeFileWithSync(cfg.path, []byte(cfg.content), cfg.perm); err != nil {
			lca.logger.Warn("write failed",
				slog.String("file", cfg.path),
				slog.String("error", err.Error()))
			continue
		}

		lca.logger.Info("config written", slog.String("file", cfg.path))
		written++
	}

	if written > 0 {
		// Reload systemd to apply changes immediately
		if err := lca.reloadSystemd(ctx); err != nil {
			lca.logger.Warn("systemd reload failed, manual restart required",
				slog.String("error", err.Error()),
				slog.String("action", "run 'systemctl daemon-reexec' manually"))
		} else {
			lca.logger.Info("systemd reloaded successfully")
		}
	}

	return nil
}

// reloadSystemd executes systemctl daemon-reexec to apply changes immediately
func (lca *LimitsConfApplier) reloadSystemd(ctx context.Context) error {
	cmd := exec.CommandContext(ctx, "systemctl", "daemon-reexec")
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("systemctl daemon-reexec failed: %w (output: %s)", err, string(output))
	}
	return nil
}
